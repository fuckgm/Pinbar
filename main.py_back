#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Pinbarç­–ç•¥ä¸»ç¨‹åº - ä¿®å¤ç‰ˆ
ä¿®å¤ä¿¡å·æ‰§è¡Œé—®é¢˜
"""

import sys
import os
import pandas as pd
import numpy as np
import backtrader as bt
from typing import Dict, Any, List, Optional, Tuple
import inquirer
import json
from datetime import datetime
import pickle
import signal

# å¯¼å…¥è‡ªå®šä¹‰æ¨¡å—
from config import ConfigManager, TradingParams, BacktestParams
from data_manager import DataManager, CustomDataFeed
from enhanced_signal_generator import EnhancedPinbarDetector, PinbarSignal
from parameter_optimizer import ParameterOptimizer
from dynamic_leverage_manager import DynamicLeverageManager
from report_generator import ReportGenerator
from enhanced_report_generator import EnhancedReportGenerator

# ä¿¡å·å¤„ç†å‡½æ•°
def signal_handler(sig, frame):
    """å¤„ç†Ctrl+Cä¿¡å·"""
    print('\nğŸ‘‹ ç¨‹åºè¢«ç”¨æˆ·ä¸­æ–­')
    sys.exit(0)

# å®‰å…¨è¾“å…¥å‡½æ•°ï¼Œæ”¯æŒESCè¿”å›
def safe_list_input(message, choices):
    """å®‰å…¨çš„åˆ—è¡¨è¾“å…¥ï¼Œæ”¯æŒESCè¿”å›"""
    try:
        return inquirer.list_input(message, choices=choices)
    except KeyboardInterrupt:
        print("\nğŸ”™ è¿”å›ä¸Šå±‚èœå•")
        return None

def safe_confirm(message, default=True):
    """å®‰å…¨çš„ç¡®è®¤è¾“å…¥ï¼Œæ”¯æŒESCè¿”å›"""
    try:
        return inquirer.confirm(message, default=default)
    except KeyboardInterrupt:
        print("\nğŸ”™ è¿”å›ä¸Šå±‚èœå•")
        return None

def safe_text_input(message, default=""):
    """å®‰å…¨çš„æ–‡æœ¬è¾“å…¥ï¼Œæ”¯æŒESCè¿”å›"""
    try:
        return inquirer.text(message, default=default)
    except KeyboardInterrupt:
        print("\nğŸ”™ è¿”å›ä¸Šå±‚èœå•")
        return None

# æœ¬åœ°æ•°æ®ç®¡ç†å‡½æ•°
def get_local_data_summary() -> Dict[str, List[str]]:
    """è·å–æœ¬åœ°å·²ä¸‹è½½æ•°æ®æ‘˜è¦"""
    data_dir = "data"
    local_data = {}
    
    if not os.path.exists(data_dir):
        return local_data
    
    for symbol_dir in os.listdir(data_dir):
        symbol_path = os.path.join(data_dir, symbol_dir)
        if os.path.isdir(symbol_path) and symbol_dir != 'cache':
            intervals = []
            for file in os.listdir(symbol_path):
                if file.endswith('.csv') or file.endswith('.pkl'):
                    interval = file.replace(f"{symbol_dir}_", "").replace(".csv", "").replace(".pkl", "")
                    if interval not in intervals:
                        intervals.append(interval)
            
            if intervals:
                local_data[symbol_dir] = sorted(intervals)
    
    return local_data

def load_local_data(symbol: str, interval: str) -> Optional[pd.DataFrame]:
    """åŠ è½½æœ¬åœ°æ•°æ®"""
    data_dir = "data"
    symbol_path = os.path.join(data_dir, symbol)
    
    pkl_file = os.path.join(symbol_path, f"{symbol}_{interval}.pkl")
    csv_file = os.path.join(symbol_path, f"{symbol}_{interval}.csv")
    
    try:
        if os.path.exists(pkl_file):
            print(f"ğŸ“ åŠ è½½æœ¬åœ°æ•°æ®: {symbol} {interval} (pickle)")
            df = pd.read_pickle(pkl_file)
        elif os.path.exists(csv_file):
            print(f"ğŸ“ åŠ è½½æœ¬åœ°æ•°æ®: {symbol} {interval} (csv)")
            df = pd.read_csv(csv_file)
            df['timestamp'] = pd.to_datetime(df['timestamp'])
        else:
            print(f"âŒ æœªæ‰¾åˆ°æœ¬åœ°æ•°æ®: {symbol} {interval}")
            return None
        
        if df is None or len(df) < 100:
            print(f"âŒ æ•°æ®ä¸è¶³: {symbol} {interval}")
            return None
        
        print(f"âœ… æˆåŠŸåŠ è½½ {len(df)} æ¡æ•°æ®")
        return df
        
    except Exception as e:
        print(f"âŒ åŠ è½½æ•°æ®å¤±è´¥: {e}")
        return None

def interactive_select_local_data() -> Tuple[Optional[str], Optional[str]]:
    """äº¤äº’å¼é€‰æ‹©æœ¬åœ°æ•°æ®"""
    local_data = get_local_data_summary()
    
    if not local_data:
        print("âŒ æœªæ‰¾åˆ°æœ¬åœ°æ•°æ®ï¼Œè¯·å…ˆä½¿ç”¨æ•°æ®ä¸‹è½½å™¨ä¸‹è½½æ•°æ®")
        return None, None
    
    print(f"\nğŸ“ å‘ç° {len(local_data)} ä¸ªå¸ç§çš„æœ¬åœ°æ•°æ®")
    
    symbol_choices = []
    for symbol, intervals in local_data.items():
        interval_str = ', '.join(intervals[:3])
        if len(intervals) > 3:
            interval_str += f'... (å…±{len(intervals)}ä¸ª)'
        symbol_choices.append((f"{symbol:<12} [{interval_str}]", symbol))
    
    selected_symbol = safe_list_input("é€‰æ‹©å¸ç§", choices=symbol_choices)
    if selected_symbol is None:
        return None, None
    
    available_intervals = local_data[selected_symbol]
    interval_choices = [(f"{interval}", interval) for interval in available_intervals]
    
    selected_interval = safe_list_input(f"é€‰æ‹© {selected_symbol} çš„æ—¶é—´å‘¨æœŸ", choices=interval_choices)
    if selected_interval is None:
        return None, None
    
    return selected_symbol, selected_interval

class EnhancedPinbarStrategy(bt.Strategy):
    """
    å¢å¼ºç‰ˆPinbarç­–ç•¥ - ä¿®å¤ç‰ˆ
    """
    
    def __init__(self, trading_params: TradingParams, 
                 detector_config: Dict[str, Any] = None,
                 use_dynamic_leverage: bool = False):
        
        print("ğŸš€ åˆå§‹åŒ–å¢å¼ºç‰ˆPinbarç­–ç•¥...")
        
        # åŸºç¡€å‚æ•°
        self.trading_params = trading_params
        self.use_dynamic_leverage = use_dynamic_leverage
        
        # äº¤æ˜“æˆæœ¬å‚æ•°
        self.commission_rate = 0.0005  # 0.05% æ‰‹ç»­è´¹
        self.funding_rate = 0.0001     # 0.01% èµ„é‡‘è´¹ç‡ï¼ˆ8å°æ—¶ï¼‰
        self.slippage_rate = 0.0002    # 0.02% æ»‘ç‚¹
        self.funding_interval_hours = 8  # èµ„é‡‘è´¹ç‡æ”¶å–é—´éš”
        
        # åˆå§‹åŒ–ä¿¡å·æ£€æµ‹å™¨
        self.pinbar_detector = EnhancedPinbarDetector(detector_config or self._get_default_detector_config())
        
        # è®¡ç®—æœ€å°æ‰€éœ€Kçº¿æ•°é‡
        self.min_required_bars = max(
            self.pinbar_detector.trend_period,
            self.pinbar_detector.rsi_period,
            self.pinbar_detector.bb_period,
            self.pinbar_detector.adx_period,
            self.pinbar_detector.atr_period,
            50  # æœ€å°‘éœ€è¦50æ ¹Kçº¿
        )
        
        # åŠ¨æ€æ æ†ç®¡ç†å™¨ï¼ˆå¯é€‰ï¼‰
        if use_dynamic_leverage:
            self.leverage_manager = DynamicLeverageManager()
            print("âœ… å¯ç”¨åŠ¨æ€æ æ†ç®¡ç†")
        
        # äº¤æ˜“çŠ¶æ€ç®¡ç†
        self.active_trades = {}
        self.trade_counter = 0
        self.trade_history = []
        self.signal_history = []
        self.executed_signals = []
        
        # ç»Ÿè®¡ä¿¡æ¯
        self.account_initial = self.broker.getcash()
        self.account_peak = self.account_initial
        self.max_dd = 0.0
        self.winning_trades = 0
        self.losing_trades = 0
        self.total_profits = 0.0
        self.total_losses = 0.0
        
        # ä¿¡å·è´¨é‡ç»Ÿè®¡
        self.signal_stats = {
            'total_signals': 0,
            'executed_signals': 0,
            'trend_aligned_signals': 0,
            'high_quality_signals': 0,
            'signal_success_rate': 0.0
        }
        
        # æ•°æ®ç¼“å­˜
        self.data_cache = []
        self.last_signal_check = 0
        
        print(f"âœ… ç­–ç•¥åˆå§‹åŒ–å®Œæˆ:")
        print(f"   - åŠ¨æ€æ æ†: {use_dynamic_leverage}")
        print(f"   - æœ€å°Kçº¿æ•°: {self.min_required_bars}")
        print(f"   - åˆå§‹èµ„é‡‘: {self.account_initial:,.2f} USDT")

    def _get_default_detector_config(self) -> Dict[str, Any]:
        """è·å–é»˜è®¤æ£€æµ‹å™¨é…ç½®"""
        return {
            'min_shadow_body_ratio': 2.0,
            'max_body_ratio': 0.35,
            'min_candle_size': 0.003,
            'trend_period': 20,
            'rsi_period': 14,
            'rsi_oversold': 30,
            'rsi_overbought': 70,
            'bb_period': 20,
            'volume_threshold': 1.3,
            'sr_lookback': 50,
            'level_proximity': 0.002,
            'min_signal_score': 3,
            'adx_period': 14,
            'adx_threshold': 25,
            'atr_period': 14,
            'atr_percentile': 30,
            'volume_ma_period': 20,
            'volume_threshold_ratio': 0.7,
            'min_consolidation_bars': 10,
            'large_move_threshold': 0.05,
            'large_move_exclude_bars': 3
        }

    def prenext(self):
        """æ•°æ®ä¸è¶³æ—¶è°ƒç”¨"""
        self._update_data_cache()

    def next(self):
        """ä¸»äº¤æ˜“é€»è¾‘"""
        # 1. æ›´æ–°å½“å‰Kçº¿æ•°æ®åˆ°ç¼“å­˜
        self._update_data_cache()
        
        # 2. æ£€æŸ¥æ•°æ®æ˜¯å¦å……è¶³
        if len(self.data_cache) < self.min_required_bars:
            return
            
        # 3. ç®¡ç†ç°æœ‰æŒä»“
        self._manage_active_trades()
        
        # 4. æ£€æŸ¥æ–°ä¿¡å·
        self._check_for_new_signals()
        
        # 5. æ›´æ–°è´¦æˆ·ç»Ÿè®¡
        self._update_account_stats()

    def _update_data_cache(self):
        """æ›´æ–°æ•°æ®ç¼“å­˜"""
        current_data = {
            'timestamp': self.data.datetime.datetime(0),
            'open': self.data.open[0],
            'high': self.data.high[0],
            'low': self.data.low[0],
            'close': self.data.close[0],
            'volume': self.data.volume[0]
        }
        
        self.data_cache.append(current_data)
        
        # ä¿ç•™æœ€è¿‘1000æ ¹Kçº¿æ•°æ®
        if len(self.data_cache) > 1000:
            self.data_cache.pop(0)

    def _check_for_new_signals(self):
        """æ£€æŸ¥å½“å‰Kçº¿æ˜¯å¦äº§ç”Ÿæ–°ä¿¡å· - ä¿®å¤ç‰ˆ"""
        
        # æ£€æŸ¥æ˜¯å¦è¾¾åˆ°æœ€å¤§æŒä»“æ•°
        if len(self.active_trades) >= self.trading_params.max_positions:
            return
        
        # å‡†å¤‡æ•°æ®
        if len(self.data_cache) < self.min_required_bars:
            return

        df = pd.DataFrame(self.data_cache)
        
        # åªæ£€æµ‹åˆ°å€’æ•°ç¬¬äºŒæ ¹Kçº¿ï¼ˆå·²å®Œæˆçš„Kçº¿ï¼‰
        df_for_signal = df[:-1]
        
        if len(df_for_signal) < self.min_required_bars:
            return
        
        try:
            # ä½¿ç”¨å¢å¼ºä¿¡å·æ£€æµ‹å™¨
            all_signals = self.pinbar_detector.detect_pinbar_patterns(df_for_signal)
            
            if all_signals:
                # åªå¤„ç†æœ€æ–°å®ŒæˆKçº¿çš„ä¿¡å·
                current_bar_index = len(df_for_signal) - 1
                new_signals = [s for s in all_signals if s.index == current_bar_index]
                
                for signal in new_signals:
                    # è®°å½•ä¿¡å·ç»Ÿè®¡
                    self.signal_stats['total_signals'] += 1
                    
                    signal_info = {
                        'timestamp': signal.timestamp,
                        'type': signal.type,
                        'direction': signal.direction,
                        'confidence_score': signal.confidence_score,
                        'signal_strength': signal.signal_strength,
                        'trend_alignment': signal.trend_alignment,
                        'entry_reason': signal.entry_reason,
                        'executed': False,
                        'execution_reason': ''
                    }
                    
                    # ç»Ÿè®¡ä¿¡å·è´¨é‡
                    if signal.trend_alignment:
                        self.signal_stats['trend_aligned_signals'] += 1
                    
                    if signal.confidence_score >= 0.7 and signal.signal_strength >= 4:
                        self.signal_stats['high_quality_signals'] += 1
                    
                    # åˆ¤æ–­æ˜¯å¦æ‰§è¡Œä¿¡å· - æ”¾å®½æ¡ä»¶
                    if self._should_execute_signal_relaxed(signal):
                        print(f"ğŸ¯ æ‰§è¡Œä¿¡å·: {signal.type} {signal.direction} @ {signal.close_price:.4f}")
                        self._execute_signal(signal)
                        signal_info['executed'] = True
                        signal_info['execution_reason'] = 'ä¿¡å·è´¨é‡è¾¾æ ‡'
                        self.signal_stats['executed_signals'] += 1
                    else:
                        signal_info['execution_reason'] = 'ä¿¡å·è´¨é‡ä¸è¶³'
                    
                    self.signal_history.append(signal_info)
                    
        except Exception as e:
            print(f"âŒ ä¿¡å·æ£€æµ‹å¤±è´¥: {e}")
            import traceback
            traceback.print_exc()

    def _should_execute_signal_relaxed(self, signal: PinbarSignal) -> bool:
        """åˆ¤æ–­æ˜¯å¦åº”è¯¥æ‰§è¡Œä¿¡å· - æ”¾å®½ç‰ˆæœ¬"""
        print(f"ğŸ” æ£€æŸ¥ä¿¡å·æ‰§è¡Œæ¡ä»¶: {signal.type} {signal.direction}")
        print(f"    ç½®ä¿¡åº¦: {signal.confidence_score:.2f}, å¼ºåº¦: {signal.signal_strength}")

        # 1. åŸºç¡€è´¨é‡æ£€æŸ¥ - å¤§å¹…æ”¾å®½
        if signal.confidence_score < 0.1:  # ä»0.3é™ä½åˆ°0.1
            print(f"âŒ ä¿¡å·è´¨é‡ä¸è¶³: ç½®ä¿¡åº¦{signal.confidence_score:.2f} < 0.1")
            return False
        
        if signal.signal_strength < 1:  # ä»2é™ä½åˆ°1
            print(f"âŒ ä¿¡å·å¼ºåº¦ä¸è¶³: {signal.signal_strength} < 1")
            return False
        
        # 2. æ£€æŸ¥èµ„é‡‘æ˜¯å¦å……è¶³
        current_cash = self.broker.getcash()
        if current_cash < 100:  # è‡³å°‘éœ€è¦100 USDT
            print(f"âŒ èµ„é‡‘ä¸è¶³: {current_cash:.2f} < 100")
            return False
        
        # 3. ç®€åŒ–çš„é£é™©æ£€æŸ¥
        current_price = signal.close_price
        stop_distance = abs(current_price - signal.stop_loss)
        
        if stop_distance <= 0:
            print(f"âŒ æ­¢æŸè·ç¦»æ— æ•ˆ: {stop_distance}")
            return False
        
        # 4. æ£€æŸ¥é£é™©å›æŠ¥æ¯”
        take_profit_distance = abs(signal.take_profit_1 - current_price)
        risk_reward_ratio = take_profit_distance / stop_distance
        
        if risk_reward_ratio < 1.0:  # è‡³å°‘1:1
            print(f"âŒ é£é™©å›æŠ¥æ¯”ä¸è¶³: {risk_reward_ratio:.2f} < 1.0")
            return False
        
        print(f"âœ… ä¿¡å·é€šè¿‡æ£€æŸ¥ï¼Œå‡†å¤‡æ‰§è¡Œ")
        return True

    def _execute_signal(self, signal: PinbarSignal):
        """æ‰§è¡Œä¿¡å·å¼€ä»“ - ä¿®å¤ç‰ˆ"""
        print(f"ğŸ“Š å¼€å§‹æ‰§è¡Œä¿¡å·: {signal.type} {signal.direction}")
        
        current_price = self.data.close[0]
        direction = signal.direction
        
        # è€ƒè™‘æ»‘ç‚¹çš„å®é™…æˆäº¤ä»·
        if direction == 'buy':
            actual_entry_price = current_price * (1 + self.slippage_rate)
        else:
            actual_entry_price = current_price * (1 - self.slippage_rate)
        
        # è®¡ç®—æ æ†
        leverage = self._calculate_dynamic_leverage(signal)
        
        # è®¡ç®—ä»“ä½å¤§å° - ç®€åŒ–ç‰ˆæœ¬
        cash = self.broker.getcash()
        risk_amount = cash * self.trading_params.risk_per_trade
        
        # æ­¢æŸè·ç¦»
        stop_distance = abs(actual_entry_price - signal.stop_loss)
        
        # è®¡ç®—ä»“ä½å¤§å°
        # ä»“ä½å¤§å° = é£é™©é‡‘é¢ / æ­¢æŸè·ç¦»
        if stop_distance > 0:
            position_value = risk_amount / (stop_distance / actual_entry_price)
            position_size = position_value / actual_entry_price
            
            # è€ƒè™‘æ æ†
            position_size = min(position_size * leverage, cash * 0.9 / actual_entry_price)
        else:
            print(f"âŒ æ­¢æŸè·ç¦»ä¸º0ï¼Œæ— æ³•è®¡ç®—ä»“ä½")
            return
        
        # æœ€å°ä»“ä½æ£€æŸ¥
        min_position_value = 10  # æœ€å°10 USDT
        if position_size * actual_entry_price < min_position_value:
            position_size = min_position_value / actual_entry_price
        
        print(f"ğŸ’° ä»“ä½è®¡ç®—:")
        print(f"    ç°é‡‘: {cash:.2f} USDT")
        print(f"    é£é™©é‡‘é¢: {risk_amount:.2f} USDT")
        print(f"    ä»“ä½å¤§å°: {position_size:.6f}")
        print(f"    ä»“ä½ä»·å€¼: {position_size * actual_entry_price:.2f} USDT")
        print(f"    æ æ†: {leverage}x")
        
        # æ‰§è¡Œå¼€ä»“
        try:
            if direction == 'buy':
                print(f"ğŸ“ˆ æ‰§è¡Œä¹°å…¥è®¢å•: {position_size:.6f} @ {actual_entry_price:.4f}")
                order = self.buy(size=position_size)
            else:
                print(f"ğŸ“‰ æ‰§è¡Œå–å‡ºè®¢å•: {position_size:.6f} @ {actual_entry_price:.4f}")
                order = self.sell(size=position_size)
            
            if order is None:
                print(f"âŒ è®¢å•æ‰§è¡Œå¤±è´¥")
                return
            
            # è®°å½•äº¤æ˜“ä¿¡æ¯
            self.trade_counter += 1
            trade_id = f"T{self.trade_counter:04d}"
            
            # è®¡ç®—æ‰‹ç»­è´¹
            commission_cost = position_size * actual_entry_price * self.commission_rate
            
            self.active_trades[trade_id] = {
                'order': order,
                'direction': direction,
                'entry_price': current_price,
                'actual_entry_price': actual_entry_price,
                'entry_time': self.data.datetime.datetime(),
                'size': position_size,
                'stop_loss': signal.stop_loss,
                'take_profit_1': signal.take_profit_1,
                'take_profit_2': signal.take_profit_2,
                'take_profit_3': signal.take_profit_3,
                'leverage': leverage,
                'signal_info': signal,
                'trailing_stop': signal.stop_loss,
                'trailing_activated': False,
                'highest_price': actual_entry_price if direction == 'buy' else 0,
                'lowest_price': actual_entry_price if direction == 'sell' else float('inf'),
                'commission_paid': commission_cost,
                'funding_paid': 0,
                'total_costs': commission_cost,
                'position_amount': position_size * actual_entry_price,
                'signal_type': signal.type,
                'signal_strength': signal.signal_strength,
                'confidence_score': signal.confidence_score,
                'trend_alignment': signal.trend_alignment,
                'entry_reason': signal.entry_reason
            }
            
            print(f"âœ… æˆåŠŸå¼€ä»“ {trade_id}: {direction} @ {actual_entry_price:.4f}")
            print(f"    æ æ†: {leverage}x | ä¿¡å·: {signal.type} | å¼ºåº¦: {signal.signal_strength}")
            print(f"    ç½®ä¿¡åº¦: {signal.confidence_score:.2f} | æ­¢æŸ: {signal.stop_loss:.4f}")
            
        except Exception as e:
            print(f"âŒ æ‰§è¡Œå¼€ä»“å¤±è´¥: {e}")
            import traceback
            traceback.print_exc()

    def _calculate_dynamic_leverage(self, signal: PinbarSignal) -> float:
        """è®¡ç®—åŠ¨æ€æ æ†"""
        base_leverage = self.trading_params.leverage
        
        if not self.use_dynamic_leverage:
            return base_leverage
        
        try:
            # æ ¹æ®ä¿¡å·è´¨é‡è°ƒæ•´æ æ†
            quality_factor = signal.confidence_score * (signal.signal_strength / 5.0)
            trend_bonus = 1.1 if signal.trend_alignment else 0.9
            
            adjusted_leverage = base_leverage * quality_factor * trend_bonus
            
            # é™åˆ¶æ æ†èŒƒå›´
            return max(1, min(base_leverage, int(adjusted_leverage)))
            
        except Exception as e:
            print(f"âŒ åŠ¨æ€æ æ†è®¡ç®—å¤±è´¥: {e}")
            return base_leverage

    def _manage_active_trades(self):
        """ç®¡ç†ç°æœ‰æŒä»“"""
        current_price = self.data.close[0]
        current_time = self.data.datetime.datetime(0)
        trades_to_close = []
        
        for trade_id, trade_info in self.active_trades.items():
            # æ£€æŸ¥æ­¢æŸ
            if self._check_stop_loss(trade_info, current_price):
                trades_to_close.append((trade_id, "æ­¢æŸ"))
                continue
            
            # æ£€æŸ¥æ­¢ç›ˆ
            exit_reason = self._check_take_profit(trade_info, current_price)
            if exit_reason:
                trades_to_close.append((trade_id, exit_reason))
        
        # æ‰§è¡Œå¹³ä»“
        for trade_id, reason in trades_to_close:
            self._close_position(trade_id, reason)

    def _check_stop_loss(self, trade_info: Dict[str, Any], current_price: float) -> bool:
        """æ£€æŸ¥æ˜¯å¦è§¦å‘æ­¢æŸ"""
        direction = trade_info['direction']
        stop_loss = trade_info['stop_loss']
        
        if direction == 'buy' and current_price <= stop_loss:
            return True
        elif direction == 'sell' and current_price >= stop_loss:
            return True
        
        return False

    def _check_take_profit(self, trade_info: Dict[str, Any], current_price: float) -> Optional[str]:
        """æ£€æŸ¥æ˜¯å¦è§¦å‘æ­¢ç›ˆ"""
        direction = trade_info['direction']
        tp1 = trade_info['take_profit_1']
        
        if direction == 'buy' and current_price >= tp1:
            return "æ­¢ç›ˆ"
        elif direction == 'sell' and current_price <= tp1:
            return "æ­¢ç›ˆ"
        
        return None

    def _close_position(self, trade_id: str, reason: str):
        """å¹³ä»“"""
        if trade_id not in self.active_trades:
            return
        
        trade_info = self.active_trades[trade_id]
        current_price = self.data.close[0]
        direction = trade_info['direction']
        
        # è€ƒè™‘æ»‘ç‚¹çš„å®é™…æˆäº¤ä»·
        if direction == 'buy':
            actual_exit_price = current_price * (1 - self.slippage_rate)
        else:
            actual_exit_price = current_price * (1 + self.slippage_rate)
        
        # è®¡ç®—å¹³ä»“æ‰‹ç»­è´¹
        exit_commission = trade_info['size'] * actual_exit_price * self.commission_rate
        
        # æ‰§è¡Œå¹³ä»“
        try:
            if direction == 'buy':
                self.sell(size=trade_info['size'])
            else:
                self.buy(size=trade_info['size'])
            
            # è®¡ç®—æ”¶ç›Š
            if direction == 'buy':
                gross_profit = (actual_exit_price - trade_info['actual_entry_price']) * trade_info['size']
            else:
                gross_profit = (trade_info['actual_entry_price'] - actual_exit_price) * trade_info['size']
            
            # æ€»æˆæœ¬
            total_costs = trade_info['total_costs'] + exit_commission
            net_profit = gross_profit - total_costs
            
            # è®°å½•äº¤æ˜“ç»“æœ
            trade_record = {
                'trade_id': trade_id,
                'direction': direction,
                'entry_time': trade_info['entry_time'],
                'exit_time': self.data.datetime.datetime(),
                'entry_price': trade_info['actual_entry_price'],
                'exit_price': actual_exit_price,
                'size': trade_info['size'],
                'gross_profit': gross_profit,
                'net_profit': net_profit,
                'profit': net_profit,
                'profit_pct': net_profit / (trade_info['actual_entry_price'] * trade_info['size']) * 100,
                'reason': reason,
                'leverage': trade_info['leverage'],
                'commission_costs': trade_info['commission_paid'] + exit_commission,
                'funding_costs': trade_info['funding_paid'],
                'total_costs': total_costs,
                'signal_type': trade_info['signal_type'],
                'signal_strength': trade_info['signal_strength'],
                'confidence_score': trade_info['confidence_score'],
                'trend_alignment': trade_info['trend_alignment'],
                'entry_reason': trade_info['entry_reason']
            }
            
            self.trade_history.append(trade_record)
            
            # æ›´æ–°ç»Ÿè®¡
            if net_profit > 0:
                self.winning_trades += 1
                self.total_profits += net_profit
            else:
                self.losing_trades += 1
                self.total_losses += abs(net_profit)
            
            del self.active_trades[trade_id]
            
            print(f"ğŸ”„ å¹³ä»“ {trade_id}: {direction} @ {actual_exit_price:.4f}")
            print(f"    å‡€åˆ©: {net_profit:.2f} USDT | åŸå› : {reason}")
            
        except Exception as e:
            print(f"âŒ å¹³ä»“å¤±è´¥: {e}")

    def _update_account_stats(self):
        """æ›´æ–°è´¦æˆ·ç»Ÿè®¡ä¿¡æ¯"""
        current_value = self.broker.getvalue()
        
        if current_value > self.account_peak:
            self.account_peak = current_value
        
        drawdown = (self.account_peak - current_value) / self.account_peak
        if drawdown > self.max_dd:
            self.max_dd = drawdown

    def stop(self):
        """å›æµ‹ç»“æŸå¤„ç†"""
        # å¹³æ‰æ‰€æœ‰æŒä»“
        for trade_id in list(self.active_trades.keys()):
            self._close_position(trade_id, "å›æµ‹ç»“æŸ")
        
        # è®¡ç®—æœ€ç»ˆä¿¡å·ç»Ÿè®¡
        if self.signal_stats['total_signals'] > 0:
            self.signal_stats['signal_execution_rate'] = (
                self.signal_stats['executed_signals'] / self.signal_stats['total_signals'] * 100
            )
        
        if self.signal_stats['executed_signals'] > 0:
            winning_signals = sum(1 for t in self.trade_history if t['profit'] > 0)
            self.signal_stats['signal_success_rate'] = (
                winning_signals / self.signal_stats['executed_signals'] * 100
            )
        
        print(f"\nğŸ“Š å›æµ‹ç»“æŸç»Ÿè®¡:")
        print(f"    æ€»ä¿¡å·: {self.signal_stats['total_signals']}")
        print(f"    æ‰§è¡Œä¿¡å·: {self.signal_stats['executed_signals']}")
        print(f"    æ‰§è¡Œç‡: {self.signal_stats.get('signal_execution_rate', 0):.1f}%")
        print(f"    æ€»äº¤æ˜“: {len(self.trade_history)}")
        print(f"    ç›ˆåˆ©äº¤æ˜“: {self.winning_trades}")

# è¿è¡Œå›æµ‹å‡½æ•°
def run_enhanced_backtest(data: pd.DataFrame, trading_params: TradingParams, 
                         backtest_params: BacktestParams,
                         detector_config: Dict[str, Any] = None,
                         use_dynamic_leverage: bool = False) -> Dict[str, Any]:
    """è¿è¡Œå¢å¼ºç‰ˆå›æµ‹"""
    print(f"ğŸš€ å¼€å§‹å¢å¼ºç‰ˆå›æµ‹: {backtest_params.symbol} {backtest_params.interval}")
    
    # è®¾ç½®Backtraderç¯å¢ƒ
    cerebro = bt.Cerebro()
    
    # æ·»åŠ æ•°æ®
    data_feed = CustomDataFeed(dataname=data)
    cerebro.adddata(data_feed)
    
    # æ·»åŠ å¢å¼ºç­–ç•¥
    cerebro.addstrategy(EnhancedPinbarStrategy, 
                       trading_params=trading_params,
                       detector_config=detector_config,
                       use_dynamic_leverage=use_dynamic_leverage)
    
    # è®¾ç½®åˆå§‹èµ„é‡‘å’Œæ‰‹ç»­è´¹
    cerebro.broker.setcash(backtest_params.initial_cash)
    cerebro.broker.setcommission(commission=backtest_params.commission)
    
    # è¿è¡Œå›æµ‹
    print(f'ğŸ’° åˆå§‹èµ„é‡‘: {backtest_params.initial_cash:,.2f} USDT')
    results = cerebro.run()
    strategy = results[0]
    
    final_value = cerebro.broker.getvalue()
    total_return = (final_value - backtest_params.initial_cash) / backtest_params.initial_cash * 100
    
    print(f'ğŸ’° æœ€ç»ˆèµ„é‡‘: {final_value:,.2f} USDT')
    print(f'ğŸ“ˆ æ€»æ”¶ç›Šç‡: {total_return:.2f}%')
    
    # è®¡ç®—è¯¦ç»†ç»Ÿè®¡
    total_trades = len(strategy.trade_history)
    signal_stats = strategy.signal_stats
    
    if total_trades > 0:
        win_rate = (strategy.winning_trades / total_trades * 100)
        avg_profit = strategy.total_profits / strategy.winning_trades if strategy.winning_trades > 0 else 0
        avg_loss = strategy.total_losses / strategy.losing_trades if strategy.losing_trades > 0 else 0
        profit_factor = avg_profit / avg_loss if avg_loss > 0 else 0
        
        # æ æ†ä½¿ç”¨åˆ†æ
        if strategy.trade_history:
            leverages = [t.get('leverage', 1) for t in strategy.trade_history]
            avg_leverage = np.mean(leverages)
            max_leverage = max(leverages)
            
            # ä¿¡å·è´¨é‡åˆ†æ
            signal_strengths = [t.get('signal_strength', 0) for t in strategy.trade_history]
            confidence_scores = [t.get('confidence_score', 0) for t in strategy.trade_history]
            trend_alignments = [t.get('trend_alignment', False) for t in strategy.trade_history]
            
            avg_signal_strength = np.mean(signal_strengths)
            avg_confidence = np.mean(confidence_scores)
            trend_alignment_rate = sum(trend_alignments) / len(trend_alignments) * 100
        else:
            avg_leverage = max_leverage = 1
            avg_signal_strength = avg_confidence = trend_alignment_rate = 0
    else:
        win_rate = profit_factor = 0
        avg_leverage = max_leverage = 1
        avg_signal_strength = avg_confidence = trend_alignment_rate = 0
    
    # å¤æ™®æ¯”ç‡
    if strategy.trade_history:
        returns = [trade['profit'] for trade in strategy.trade_history]
        sharpe_ratio = np.mean(returns) / np.std(returns) if np.std(returns) > 0 else 0
    else:
        sharpe_ratio = 0
    
    # æ‰“å°ä¿¡å·è´¨é‡ç»Ÿè®¡
    print(f"\nğŸ“Š ä¿¡å·è´¨é‡ç»Ÿè®¡:")
    print(f"   æ€»ä¿¡å·æ•°: {signal_stats['total_signals']}")
    print(f"   æ‰§è¡Œä¿¡å·æ•°: {signal_stats['executed_signals']}")
    print(f"   æ‰§è¡Œç‡: {signal_stats.get('signal_execution_rate', 0):.1f}%")
    print(f"   ä¿¡å·æˆåŠŸç‡: {signal_stats.get('signal_success_rate', 0):.1f}%")
    
    return {
        'initial_cash': backtest_params.initial_cash,
        'final_value': final_value,
        'total_return': total_return,
        'total_trades': total_trades,
        'win_trades': strategy.winning_trades,
        'lose_trades': strategy.losing_trades,
        'win_rate': win_rate,
        'profit_factor': profit_factor,
        'max_drawdown': strategy.max_dd,
        'sharpe_ratio': sharpe_ratio,
        'avg_leverage': avg_leverage,
        'max_leverage': max_leverage,
        'trades': strategy.trade_history,
        'signals': strategy.signal_history,
        'executed_signals': strategy.executed_signals,
        'use_dynamic_leverage': use_dynamic_leverage,
        'signal_stats': signal_stats,
        'avg_signal_strength': avg_signal_strength,
        'avg_confidence_score': avg_confidence,
        'trend_alignment_rate': trend_alignment_rate
    }

# å…¶ä»–å‡½æ•°ä¿æŒä¸å˜...
def parameter_optimization(config_manager: ConfigManager, data_manager: DataManager):
    """å‚æ•°ä¼˜åŒ–åŠŸèƒ½"""
    print("\nğŸ”§ æ™ºèƒ½å‚æ•°ä¼˜åŒ–æ¨¡å¼")
    print("=" * 50)
    
    # é€‰æ‹©æ•°æ®æº
    data_source_choices = [
        ('ğŸ“ ä½¿ç”¨æœ¬åœ°ä¸‹è½½æ•°æ®', 'local'),
        ('ğŸŒ åœ¨çº¿è·å–æ•°æ®', 'online')
    ]
    
    data_source = safe_list_input("é€‰æ‹©æ•°æ®æº", choices=data_source_choices)
    if data_source is None:
        return
    
    # é€‰æ‹©ä¼˜åŒ–ç±»å‹
    optimization_choices = [
        ('ğŸ¯ ç½‘æ ¼æœç´¢ (å…¨é¢ä½†è€—æ—¶)', 'grid'),
        ('ğŸ² éšæœºæœç´¢ (å¿«é€Ÿé‡‡æ ·)', 'random'),
        ('ğŸ“‹ é¢„è®¾é…ç½®æµ‹è¯•', 'preset')
    ]
    
    optimization_type = safe_list_input("é€‰æ‹©ä¼˜åŒ–æ–¹å¼", choices=optimization_choices)
    if optimization_type is None:
        return
    
    # è·å–æ•°æ®
    if data_source == 'local':
        symbol, interval = interactive_select_local_data()
        if not symbol or not interval:
            print("âŒ æœªé€‰æ‹©æœ‰æ•ˆæ•°æ®")
            return
        
        data = load_local_data(symbol, interval)
        if data is None:
            print("âŒ æ•°æ®åŠ è½½å¤±è´¥")
            return
    else:
        # åœ¨çº¿æ•°æ®
        symbol = config_manager.backtest_params.symbol
        print(f"ğŸ“Š è·å– {symbol} æ•°æ®...")
        
        data = data_manager.get_historical_data(
            symbol=symbol,
            interval=config_manager.backtest_params.interval,
            start_date=config_manager.backtest_params.start_date,
            end_date=config_manager.backtest_params.end_date
        )
        
        if data is None or len(data) < 100:
            print("âŒ æ•°æ®è·å–å¤±è´¥æˆ–æ•°æ®ä¸è¶³")
            return
    
    # åˆ›å»ºå‚æ•°ä¼˜åŒ–å™¨
    optimizer = ParameterOptimizer()
    
    # è®¾ç½®ä¼˜åŒ–èŒƒå›´
    if optimization_type == 'grid':
        max_workers = safe_text_input("å¹¶è¡Œè¿›ç¨‹æ•° (é»˜è®¤4)", default="4")
        try:
            max_workers = int(max_workers)
        except:
            max_workers = 4
    else:
        max_workers = 2
    
    print(f"\nğŸš€ å¼€å§‹æ™ºèƒ½å‚æ•°ä¼˜åŒ–...")
    print(f"ğŸ“Š ä¼˜åŒ–æ–¹å¼: {optimization_type}")
    print(f"ğŸ“ˆ æ•°æ®é•¿åº¦: {len(data)} æ¡")
    print(f"âš¡ å¹¶è¡Œè¿›ç¨‹: {max_workers}")
    
    # æ‰§è¡Œä¼˜åŒ–
    try:
        optimization_results = optimizer.optimize_parameters(
            data=data,
            optimization_type=optimization_type,
            max_workers=max_workers
        )
        
        if optimization_results:
            # æ˜¾ç¤ºç»“æœ
            optimizer.print_optimization_results(optimization_results)
            
            # è¯¢é—®æ˜¯å¦åº”ç”¨æœ€ä½³å‚æ•°
            apply_best = safe_confirm("ğŸ¯ æ˜¯å¦åº”ç”¨æœ€ä½³å‚æ•°åˆ°é…ç½®æ–‡ä»¶?", default=True)
            if apply_best:
                optimizer.apply_best_params(optimization_results)
            
            # è¯¢é—®æ˜¯å¦ä¿å­˜ç»“æœ
            save_results = safe_confirm("ğŸ’¾ æ˜¯å¦ä¿å­˜ä¼˜åŒ–ç»“æœ?", default=True)
            if save_results:
                optimizer.save_optimization_results(optimization_results)
        else:
            print("âŒ å‚æ•°ä¼˜åŒ–å¤±è´¥")
            
    except Exception as e:
        print(f"âŒ å‚æ•°ä¼˜åŒ–è¿‡ç¨‹å‡ºé”™: {e}")
        import traceback
        traceback.print_exc()

def quick_backtest(config_manager: ConfigManager, data_manager: DataManager, 
                  report_generator: ReportGenerator):
    """å¿«é€Ÿå›æµ‹ - å¢å¼ºç‰ˆ"""
    print("\nğŸš€ å¿«é€Ÿå›æµ‹æ¨¡å¼ï¼ˆå¢å¼ºç‰ˆï¼‰")
    
    # é€‰æ‹©æ•°æ®æº
    data_source_choices = [
        ('ğŸ“ ä½¿ç”¨æœ¬åœ°ä¸‹è½½æ•°æ®', 'local'),
        ('ğŸŒ åœ¨çº¿è·å–æ•°æ®', 'online')
    ]
    
    data_source = safe_list_input("é€‰æ‹©æ•°æ®æº", choices=data_source_choices)
    if data_source is None:
        return
    
    # é€‰æ‹©å¢å¼ºåŠŸèƒ½
    use_dynamic_leverage = safe_confirm("ğŸ¯ æ˜¯å¦ä½¿ç”¨åŠ¨æ€æ æ†ç®¡ç†?", default=True)
    
    trading_params = config_manager.trading_params
    backtest_params = config_manager.backtest_params
    
    # è·å–æ•°æ®
    if data_source == 'local':
        symbol, interval = interactive_select_local_data()
        if not symbol or not interval:
            print("âŒ æœªé€‰æ‹©æœ‰æ•ˆæ•°æ®")
            return
        
        backtest_params.symbol = symbol
        backtest_params.interval = interval
        data = load_local_data(symbol, interval)
        if data is None:
            print("âŒ æ•°æ®åŠ è½½å¤±è´¥")
            return
    else:
        # åœ¨çº¿æ•°æ® - åªæä¾›é€‰æ‹©ï¼Œä¸æä¾›è¾“å…¥
        try:
            # è·å–çƒ­é—¨å¸ç§åˆ—è¡¨
            print("ğŸ“Š è·å–çƒ­é—¨å¸ç§åˆ—è¡¨...")
            all_symbols = data_manager.get_top_symbols(20)
            
            if not all_symbols:
                print("âš ï¸ è·å–å¸ç§åˆ—è¡¨å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤åˆ—è¡¨")
                all_symbols = ['BTCUSDT', 'ETHUSDT', 'BNBUSDT', 'ADAUSDT', 'XRPUSDT', 
                              'SOLUSDT', 'DOTUSDT', 'DOGEUSDT', 'AVAXUSDT', 'MATICUSDT']
            
            # åˆ›å»ºé€‰æ‹©åˆ—è¡¨ï¼ˆåªæ˜¾ç¤ºå‰10ä¸ªçƒ­é—¨å¸ç§ï¼‰
            symbol_choices = []
            for i, symbol in enumerate(all_symbols[:10], 1):
                symbol_choices.append((f"{i:2d}. {symbol}", symbol))
            
            # é€‰æ‹©å¸ç§
            selected_symbol = safe_list_input("é€‰æ‹©äº¤æ˜“å¯¹", choices=symbol_choices)
            if selected_symbol is None:
                return
            
            backtest_params.symbol = selected_symbol
            
        except Exception as e:
            print(f"âŒ è·å–å¸ç§åˆ—è¡¨å¤±è´¥: {e}")
            print("ä½¿ç”¨é»˜è®¤å¸ç§BTCUSDT")
            backtest_params.symbol = 'BTCUSDT'
        
        # é€‰æ‹©æ—¶é—´å‘¨æœŸ
        interval_choices = [
            ('1åˆ†é’Ÿ (1m)', '1m'),
            ('5åˆ†é’Ÿ (5m)', '5m'),
            ('15åˆ†é’Ÿ (15m)', '15m'),
            ('30åˆ†é’Ÿ (30m)', '30m'),
            ('1å°æ—¶ (1h)', '1h'),
            ('4å°æ—¶ (4h)', '4h'),
            ('1å¤© (1d)', '1d')
        ]
        
        selected_interval = safe_list_input("é€‰æ‹©æ—¶é—´å‘¨æœŸ", choices=interval_choices)
        if selected_interval is None:
            selected_interval = '1h'  # é»˜è®¤1å°æ—¶
        
        backtest_params.interval = selected_interval
        
        print(f"ğŸ“Š è·å– {backtest_params.symbol} {backtest_params.interval} æ•°æ®...")
        data = data_manager.get_historical_data(
            symbol=backtest_params.symbol,
            interval=backtest_params.interval,
            start_date=backtest_params.start_date,
            end_date=backtest_params.end_date
        )
        
        if data is None or len(data) < 100:
            print("âŒ æ•°æ®è·å–å¤±è´¥æˆ–æ•°æ®ä¸è¶³")
            return
    
    # æ˜¾ç¤ºæ•°æ®ä¿¡æ¯
    print(f"\nğŸ“Š æ•°æ®ä¿¡æ¯:")
    print(f"  å¸ç§: {backtest_params.symbol}")
    print(f"  å‘¨æœŸ: {backtest_params.interval}")
    print(f"  æ•°æ®é‡: {len(data)} æ¡")
    if 'timestamp' in data.columns:
        print(f"  æ—¶é—´èŒƒå›´: {data['timestamp'].min()} ~ {data['timestamp'].max()}")
    
    # è¿è¡Œå¢å¼ºç‰ˆå›æµ‹
    print(f"\nğŸš€ å¼€å§‹å›æµ‹...")
    results = run_enhanced_backtest(
        data=data, 
        trading_params=trading_params, 
        backtest_params=backtest_params,
        use_dynamic_leverage=use_dynamic_leverage
    )
    
    # ç”ŸæˆæŠ¥å‘Šé…ç½®
    config_dict = {
        'symbol': backtest_params.symbol,
        'interval': backtest_params.interval,
        'leverage': trading_params.leverage,
        'risk_per_trade': trading_params.risk_per_trade,
        'stop_loss_pct': trading_params.stop_loss_pct,
        'take_profit_pct': trading_params.take_profit_pct,
        'data_source': data_source,
        'use_dynamic_leverage': use_dynamic_leverage,
        # æ–°å¢ä¿¡å·è´¨é‡ä¿¡æ¯
        'signal_execution_rate': results.get('signal_stats', {}).get('signal_execution_rate', 0),
        'avg_signal_strength': results.get('avg_signal_strength', 0),
        'avg_confidence_score': results.get('avg_confidence_score', 0),
        'trend_alignment_rate': results.get('trend_alignment_rate', 0),
        'total_signals': results.get('signal_stats', {}).get('total_signals', 0),
        'high_quality_signals': results.get('signal_stats', {}).get('high_quality_signals', 0)
    }
    
    # ç”Ÿæˆå¢å¼ºç‰ˆæŠ¥å‘Š
    print("\nğŸ“Š è‡ªåŠ¨ç”Ÿæˆå¢å¼ºç‰ˆå›æµ‹æŠ¥å‘Š...")
    try:
        enhanced_generator = EnhancedReportGenerator()
        report_path = enhanced_generator.generate_enhanced_backtest_report(data, results, config_dict)
        
        print("ğŸš€ è‡ªåŠ¨åœ¨æµè§ˆå™¨ä¸­æ‰“å¼€æŠ¥å‘Š...")
        enhanced_generator.open_report_in_browser(report_path)
        
    except Exception as e:
        print(f"âŒ å¢å¼ºç‰ˆæŠ¥å‘Šç”Ÿæˆå¤±è´¥: {e}")
        print("ğŸ”„ å°è¯•ç”Ÿæˆæ ‡å‡†æŠ¥å‘Š...")
        try:
            report_path = report_generator.generate_backtest_report(data, results, config_dict)
            auto_open = safe_confirm("æ˜¯å¦åœ¨æµè§ˆå™¨ä¸­æ‰“å¼€æ ‡å‡†æŠ¥å‘Š?", default=True)
            if auto_open:
                report_generator.open_report_in_browser(report_path)
        except Exception as e2:
            print(f"âŒ æ ‡å‡†æŠ¥å‘Šä¹Ÿç”Ÿæˆå¤±è´¥: {e2}")
    
    print("ğŸ”™ è¿”å›ä¸»èœå•")

def custom_backtest(config_manager: ConfigManager, data_manager: DataManager,
                   report_generator: ReportGenerator):
    """è‡ªå®šä¹‰é…ç½®å›æµ‹ - å¢å¼ºç‰ˆ"""
    print("\nâš™ï¸ è‡ªå®šä¹‰é…ç½®å›æµ‹ï¼ˆå¢å¼ºç‰ˆï¼‰")
    
    # é€‰æ‹©æ•°æ®æº
    data_source_choices = [
        ('ğŸ“ ä½¿ç”¨æœ¬åœ°ä¸‹è½½æ•°æ®', 'local'),
        ('ğŸŒ åœ¨çº¿è·å–æ•°æ®', 'online')
    ]
    
    data_source = safe_list_input("é€‰æ‹©æ•°æ®æº", choices=data_source_choices)
    if data_source is None:
        return
    
    # äº¤äº’å¼é…ç½®å‚æ•°
    config_manager.interactive_config()
    config_manager.print_current_config()
    
    # é€‰æ‹©å¢å¼ºåŠŸèƒ½
    use_dynamic_leverage = safe_confirm("ğŸ¯ æ˜¯å¦ä½¿ç”¨åŠ¨æ€æ æ†ç®¡ç†?", default=True)
    
    if not config_manager.validate_config():
        continue_anyway = safe_confirm("é…ç½®å­˜åœ¨é—®é¢˜ï¼Œæ˜¯å¦ç»§ç»­?", default=False)
        if not continue_anyway:
            return
    
    # ä¿å­˜é…ç½®
    save_config = safe_confirm("ğŸ’¾ æ˜¯å¦ä¿å­˜å½“å‰é…ç½®ï¼Ÿ", default=True)
    if save_config:
        config_manager.save_config()
    
    # è·å–æ•°æ®
    if data_source == 'local':
        symbol, interval = interactive_select_local_data()
        if not symbol or not interval:
            print("âŒ æœªé€‰æ‹©æœ‰æ•ˆæ•°æ®")
            return
        
        config_manager.backtest_params.symbol = symbol
        config_manager.backtest_params.interval = interval
        data = load_local_data(symbol, interval)
        if data is None:
            print("âŒ æ•°æ®åŠ è½½å¤±è´¥")
            return
    else:
        symbol = config_manager.backtest_params.symbol
        print(f"ğŸ“Š è·å– {symbol} æ•°æ®...")
        
        data = data_manager.get_historical_data(
            symbol=symbol,
            interval=config_manager.backtest_params.interval,
            start_date=config_manager.backtest_params.start_date,
            end_date=config_manager.backtest_params.end_date
        )
        
        if data is None or len(data) < 100:
            print("âŒ æ•°æ®è·å–å¤±è´¥æˆ–æ•°æ®ä¸è¶³")
            return
    
    # è¿è¡Œå¢å¼ºç‰ˆå›æµ‹
    results = run_enhanced_backtest(
        data=data, 
        trading_params=config_manager.trading_params, 
        backtest_params=config_manager.backtest_params,
        use_dynamic_leverage=use_dynamic_leverage
    )
    
    # ç”ŸæˆæŠ¥å‘Šé…ç½®
    config_dict = config_manager.trading_params.__dict__.copy()
    config_dict.update(config_manager.backtest_params.__dict__)
    config_dict['data_source'] = data_source
    config_dict['use_dynamic_leverage'] = use_dynamic_leverage
    # æ–°å¢ä¿¡å·è´¨é‡ä¿¡æ¯
    config_dict.update({
        'signal_execution_rate': results.get('signal_stats', {}).get('signal_execution_rate', 0),
        'avg_signal_strength': results.get('avg_signal_strength', 0),
        'avg_confidence_score': results.get('avg_confidence_score', 0),
        'trend_alignment_rate': results.get('trend_alignment_rate', 0),
        'total_signals': results.get('signal_stats', {}).get('total_signals', 0),
        'high_quality_signals': results.get('signal_stats', {}).get('high_quality_signals', 0)
    })
    
    # ç”Ÿæˆå¢å¼ºç‰ˆæŠ¥å‘Š
    print("\nğŸ“Š è‡ªåŠ¨ç”Ÿæˆå¢å¼ºç‰ˆå›æµ‹æŠ¥å‘Š...")
    try:
        enhanced_generator = EnhancedReportGenerator()
        report_path = enhanced_generator.generate_enhanced_backtest_report(data, results, config_dict)
        
        print("ğŸš€ è‡ªåŠ¨åœ¨æµè§ˆå™¨ä¸­æ‰“å¼€æŠ¥å‘Š...")
        enhanced_generator.open_report_in_browser(report_path)
        
    except Exception as e:
        print(f"âŒ å¢å¼ºç‰ˆæŠ¥å‘Šç”Ÿæˆå¤±è´¥: {e}")
        print("ğŸ”„ å°è¯•ç”Ÿæˆæ ‡å‡†æŠ¥å‘Š...")
        try:
            report_path = report_generator.generate_backtest_report(data, results, config_dict)
            auto_open = safe_confirm("æ˜¯å¦åœ¨æµè§ˆå™¨ä¸­æ‰“å¼€æ ‡å‡†æŠ¥å‘Š?", default=True)
            if auto_open:
                report_generator.open_report_in_browser(report_path)
        except Exception as e2:
            print(f"âŒ æ ‡å‡†æŠ¥å‘Šä¹Ÿç”Ÿæˆå¤±è´¥: {e2}")
    
    print("ğŸ”™ è¿”å›ä¸»èœå•")

def multi_symbol_backtest(config_manager: ConfigManager, data_manager: DataManager, 
                         report_generator: ReportGenerator):
    """å¤šå¸ç§åŒæ—¶å›æµ‹"""
    print("\nğŸ¯ å¤šå¸ç§åŒæ—¶å›æµ‹æ¨¡å¼")
    print("=" * 50)
    
    # é€‰æ‹©æ•°æ®æº
    data_source_choices = [
        ('ğŸ“ ä½¿ç”¨æœ¬åœ°ä¸‹è½½æ•°æ®', 'local'),
        ('ğŸŒ åœ¨çº¿è·å–æ•°æ®', 'online')
    ]
    
    data_source = safe_list_input("é€‰æ‹©æ•°æ®æº", choices=data_source_choices)
    if data_source is None:
        return
    
    # é€‰æ‹©å¸ç§
    symbols_to_test = []
    
    if data_source == 'local':
        local_data = get_local_data_summary()
        if not local_data:
            print("âŒ æœªæ‰¾åˆ°æœ¬åœ°æ•°æ®")
            return
        
        print(f"\nğŸ“ å‘ç° {len(local_data)} ä¸ªå¸ç§çš„æœ¬åœ°æ•°æ®")
        
        # æ‰¹é‡é€‰æ‹©æˆ–é¢„è®¾ç»„åˆ
        selection_choices = [
            ('ğŸ¯ é€‰æ‹©çƒ­é—¨å¸ç§ç»„åˆ', 'popular'),
            ('ğŸ“Š é€‰æ‹©ä¸»æµå¸ç§ç»„åˆ', 'major'),
            ('ğŸ”§ è‡ªå®šä¹‰é€‰æ‹©å¸ç§', 'custom'),
            ('ğŸ“ˆ å…¨éƒ¨æœ¬åœ°å¸ç§', 'all')
        ]
        
        selection_type = safe_list_input("é€‰æ‹©å¸ç§æ–¹å¼", choices=selection_choices)
        if selection_type is None:
            return
        
        if selection_type == 'popular':
            # çƒ­é—¨å¸ç§ç»„åˆ
            popular_symbols = ['BTCUSDT', 'ETHUSDT', 'BNBUSDT', 'ADAUSDT', 'XRPUSDT']
            symbols_to_test = [s for s in popular_symbols if s in local_data]
        elif selection_type == 'major':
            # ä¸»æµå¸ç§ç»„åˆ
            major_symbols = ['BTCUSDT', 'ETHUSDT', 'BNBUSDT', 'SOLUSDT', 'DOTUSDT', 'AVAXUSDT']
            symbols_to_test = [s for s in major_symbols if s in local_data]
        elif selection_type == 'all':
            # å…¨éƒ¨å¸ç§
            symbols_to_test = list(local_data.keys())
        else:
            # è‡ªå®šä¹‰é€‰æ‹©
            symbol_choices = [(symbol, symbol) for symbol in local_data.keys()]
            selected_symbols = []
            
            print("\nğŸ“‹ å¯é€‰å¸ç§:")
            for i, symbol in enumerate(local_data.keys(), 1):
                print(f"{i:2d}. {symbol}")
            
            while True:
                symbol_input = safe_text_input("è¾“å…¥å¸ç§ç¼–å·(ç”¨é€—å·åˆ†éš”,å¦‚:1,2,3)æˆ–ç›´æ¥å›è½¦ç»“æŸ", default="")
                if not symbol_input:
                    break
                
                try:
                    indices = [int(x.strip()) for x in symbol_input.split(',')]
                    symbol_list = list(local_data.keys())
                    for idx in indices:
                        if 1 <= idx <= len(symbol_list):
                            symbol = symbol_list[idx-1]
                            if symbol not in selected_symbols:
                                selected_symbols.append(symbol)
                    
                    if selected_symbols:
                        print(f"âœ… å·²é€‰æ‹©: {', '.join(selected_symbols)}")
                        symbols_to_test = selected_symbols
                        break
                except:
                    print("âŒ è¾“å…¥æ ¼å¼é”™è¯¯ï¼Œè¯·é‡æ–°è¾“å…¥")
        
        if not symbols_to_test:
            print("âŒ æœªé€‰æ‹©ä»»ä½•å¸ç§")
            return
        
        # é€‰æ‹©æ—¶é—´å‘¨æœŸ
        available_intervals = set()
        for symbol in symbols_to_test:
            available_intervals.update(local_data[symbol])
        
        interval_choices = [(interval, interval) for interval in sorted(available_intervals)]
        selected_interval = safe_list_input("é€‰æ‹©æ—¶é—´å‘¨æœŸ", choices=interval_choices)
        if selected_interval is None:
            return
    
    else:
        # åœ¨çº¿æ•°æ®
        try:
            all_symbols = data_manager.get_top_symbols(20)
            
            # é¢„è®¾ç»„åˆé€‰æ‹©
            preset_choices = [
                ('ğŸ¯ å‰5å¤§å¸ç§', all_symbols[:5]),
                ('ğŸ“Š å‰10å¤§å¸ç§', all_symbols[:10]),
                ('ğŸ”§ è‡ªå®šä¹‰é€‰æ‹©', 'custom')
            ]
            
            preset_choice = safe_list_input("é€‰æ‹©å¸ç§ç»„åˆ", choices=[(desc, symbols) for desc, symbols in preset_choices])
            if preset_choice is None:
                return
            
            if preset_choice == 'custom':
                # è‡ªå®šä¹‰é€‰æ‹©
                symbol_choices = [(f"{symbol} (ç¬¬{i+1}å)", symbol) for i, symbol in enumerate(all_symbols)]
                symbols_to_test = []
                
                print("\nğŸ“‹ å¯é€‰å¸ç§ (æŒ‰äº¤æ˜“é‡æ’åº):")
                for i, symbol in enumerate(all_symbols, 1):
                    print(f"{i:2d}. {symbol}")
                
                symbol_input = safe_text_input("è¾“å…¥å¸ç§ç¼–å·(ç”¨é€—å·åˆ†éš”,å¦‚:1,2,3)", default="1,2,3")
                if not symbol_input:
                    return
                
                try:
                    indices = [int(x.strip()) for x in symbol_input.split(',')]
                    for idx in indices:
                        if 1 <= idx <= len(all_symbols):
                            symbols_to_test.append(all_symbols[idx-1])
                except:
                    print("âŒ è¾“å…¥æ ¼å¼é”™è¯¯")
                    return
            else:
                symbols_to_test = preset_choice
            
            selected_interval = config_manager.backtest_params.interval
            
        except Exception as e:
            print(f"âŒ è·å–å¸ç§åˆ—è¡¨å¤±è´¥: {e}")
            return
    
    if not symbols_to_test:
        print("âŒ æœªé€‰æ‹©ä»»ä½•å¸ç§")
        return
    
    # é€‰æ‹©å¢å¼ºåŠŸèƒ½
    use_dynamic_leverage = safe_confirm("ğŸ¯ æ˜¯å¦ä½¿ç”¨åŠ¨æ€æ æ†ç®¡ç†?", default=True)
    
    print(f"\nğŸš€ å¼€å§‹å¤šå¸ç§å›æµ‹...")
    print(f"ğŸ“Š å¸ç§æ•°é‡: {len(symbols_to_test)}")
    print(f"ğŸ“ˆ æ—¶é—´å‘¨æœŸ: {selected_interval}")
    print(f"âš¡ åŠ¨æ€æ æ†: {use_dynamic_leverage}")
    print(f"ğŸ’° æ¯å¸ç§åˆå§‹èµ„é‡‘: {config_manager.backtest_params.initial_cash:,.0f} USDT")
    
    # æ‰§è¡Œå¤šå¸ç§å›æµ‹
    multi_results = {}
    total_initial_cash = 0
    total_final_value = 0
    
    for i, symbol in enumerate(symbols_to_test, 1):
        print(f"\n[{i}/{len(symbols_to_test)}] ğŸ“Š å›æµ‹ {symbol}...")
        
        # è·å–æ•°æ®
        if data_source == 'local':
            data = load_local_data(symbol, selected_interval)
        else:
            data = data_manager.get_historical_data(
                symbol=symbol,
                interval=selected_interval,
                start_date=config_manager.backtest_params.start_date,
                end_date=config_manager.backtest_params.end_date
            )
        
        if data is None or len(data) < 100:
            print(f"âŒ {symbol} æ•°æ®ä¸è¶³ï¼Œè·³è¿‡")
            continue
        
        # åˆ›å»ºè¯¥å¸ç§çš„å›æµ‹å‚æ•°
        symbol_backtest_params = BacktestParams(
            symbol=symbol,
            interval=selected_interval,
            initial_cash=config_manager.backtest_params.initial_cash,
            commission=config_manager.backtest_params.commission,
            start_date=config_manager.backtest_params.start_date,
            end_date=config_manager.backtest_params.end_date
        )
        
        # è¿è¡Œå›æµ‹
        try:
            results = run_enhanced_backtest(
                data=data,
                trading_params=config_manager.trading_params,
                backtest_params=symbol_backtest_params,
                use_dynamic_leverage=use_dynamic_leverage
            )
            
            multi_results[symbol] = {
                'results': results,
                'data': data,
                'symbol': symbol,
                'interval': selected_interval
            }
            
            total_initial_cash += results['initial_cash']
            total_final_value += results['final_value']
            
            print(f"âœ… {symbol}: {results['total_return']:.2f}% | äº¤æ˜“: {results['total_trades']} | èƒœç‡: {results['win_rate']:.1f}%")
            
        except Exception as e:
            print(f"âŒ {symbol} å›æµ‹å¤±è´¥: {e}")
            continue
    
    if not multi_results:
        print("âŒ æ‰€æœ‰å¸ç§å›æµ‹å‡å¤±è´¥")
        return
    
    # è®¡ç®—æ€»ä½“ç»Ÿè®¡
    total_return = (total_final_value - total_initial_cash) / total_initial_cash * 100 if total_initial_cash > 0 else 0
    
    print(f"\nğŸ¯ å¤šå¸ç§å›æµ‹æ±‡æ€»:")
    print(f"ğŸ“Š æˆåŠŸå›æµ‹å¸ç§: {len(multi_results)}")
    print(f"ğŸ’° æ€»æŠ•å…¥èµ„é‡‘: {total_initial_cash:,.0f} USDT")
    print(f"ğŸ’° æ€»æœ€ç»ˆä»·å€¼: {total_final_value:,.0f} USDT")
    print(f"ğŸ“ˆ æ€»ä½“æ”¶ç›Šç‡: {total_return:.2f}%")
    
    # æŒ‰æ”¶ç›Šç‡æ’åºæ˜¾ç¤º
    sorted_results = sorted(multi_results.items(), key=lambda x: x[1]['results']['total_return'], reverse=True)
    
    print(f"\nğŸ“Š å„å¸ç§è¡¨ç°æ’è¡Œ:")
    print(f"{'æ’å':<4} {'å¸ç§':<12} {'æ”¶ç›Šç‡':<10} {'äº¤æ˜“æ•°':<8} {'èƒœç‡':<8} {'æœ€å¤§å›æ’¤':<10}")
    print("-" * 60)
    
    for rank, (symbol, data) in enumerate(sorted_results, 1):
        results = data['results']
        print(f"{rank:<4} {symbol:<12} {results['total_return']:>8.2f}% {results['total_trades']:>6} "
              f"{results['win_rate']:>6.1f}% {results['max_drawdown']*100:>8.2f}%")
    
    # ç”Ÿæˆå¤šå¸ç§æŠ¥å‘Š
    print("\nğŸ“Š ç”Ÿæˆå¤šå¸ç§å›æµ‹æŠ¥å‘Š...")
    try:
        enhanced_generator = EnhancedReportGenerator()
        report_path = enhanced_generator.generate_multi_symbol_report(multi_results, {
            'data_source': data_source,
            'use_dynamic_leverage': use_dynamic_leverage,
            'total_initial_cash': total_initial_cash,
            'total_final_value': total_final_value,
            'total_return': total_return,
            'config': config_manager.trading_params.__dict__
        })
        
        print("ğŸš€ è‡ªåŠ¨åœ¨æµè§ˆå™¨ä¸­æ‰“å¼€æŠ¥å‘Š...")
        enhanced_generator.open_report_in_browser(report_path)
        
    except Exception as e:
        print(f"âŒ å¤šå¸ç§æŠ¥å‘Šç”Ÿæˆå¤±è´¥: {e}")
        import traceback
        traceback.print_exc()
    
    print("ğŸ”™ è¿”å›ä¸»èœå•")

def main():
    """ä¸»ç¨‹åºå…¥å£"""
    print("=" * 60)
    print("ğŸ¯ æ¨¡å—åŒ–Pinbarç­–ç•¥å›æµ‹ç³»ç»Ÿ - ä¿®å¤ç‰ˆ")
    print("=" * 60)
    print("âœ¨ ä¿®å¤å†…å®¹:")
    print("   ğŸ”§ ä¿¡å·æ‰§è¡Œé€»è¾‘ä¼˜åŒ– - æ”¾å®½æ‰§è¡Œæ¡ä»¶")
    print("   ğŸ“Š ä»“ä½è®¡ç®—ä¿®å¤ - ç¡®ä¿æ­£ç¡®è®¡ç®—ä»“ä½å¤§å°")
    print("   ğŸ¯ è®¢å•æ‰§è¡Œå¢å¼º - å¢åŠ è¯¦ç»†è°ƒè¯•ä¿¡æ¯")
    print("   ğŸ“ˆ é”™è¯¯å¤„ç†å®Œå–„ - æ›´å¥½çš„å¼‚å¸¸å¤„ç†æœºåˆ¶")
    print("   ğŸ”„ äº¤æ˜“çŠ¶æ€ç®¡ç† - å®Œå–„æ­¢æŸæ­¢ç›ˆé€»è¾‘")
    print("ğŸ’¡ æç¤º: ä½¿ç”¨ Ctrl+C æˆ– ESC é”®å¯ä»¥è¿”å›ä¸Šå±‚èœå•")
    
    # è®¾ç½®ä¿¡å·å¤„ç†
    signal.signal(signal.SIGINT, signal_handler)
    
    # åˆå§‹åŒ–ç®¡ç†å™¨
    config_manager = ConfigManager()
    data_manager = DataManager()
    report_generator = ReportGenerator()
    
    # ä¸»èœå•
    while True:
        print("\nğŸ“‹ ä¸»èœå•:")
        choices = [
            'ğŸš€ å¿«é€Ÿå›æµ‹ (ä¿®å¤ç‰ˆ)',
            'âš™ï¸  é…ç½®å‚æ•°åå›æµ‹ (ä¿®å¤ç‰ˆ)',
            'ğŸ¯ å¤šå¸ç§åŒæ—¶å›æµ‹',
            'ğŸ”§ æ™ºèƒ½å‚æ•°ä¼˜åŒ–',
            'ğŸ“Š å¤šé…ç½®å¯¹æ¯”æµ‹è¯•',
            'ğŸ“ˆ å¤šç­–ç•¥å¯¹æ¯”',
            'â¬‡ï¸  æ•°æ®ä¸‹è½½å™¨',
            'ğŸ“ æŸ¥çœ‹æœ¬åœ°æ•°æ®',
            'âŒ é€€å‡ºç¨‹åº'
        ]
        
        choice = safe_list_input("è¯·é€‰æ‹©æ“ä½œ (ESCè¿”å›)", choices=choices)
        if choice is None:
            print("ğŸ‘‹ ç¨‹åºé€€å‡º")
            return
        
        if choice == choices[0]:  # å¿«é€Ÿå›æµ‹
            quick_backtest(config_manager, data_manager, report_generator)
        
        elif choice == choices[1]:  # é…ç½®å‚æ•°åå›æµ‹
            custom_backtest(config_manager, data_manager, report_generator)
        
        elif choice == choices[2]:  # å¤šå¸ç§åŒæ—¶å›æµ‹
            multi_symbol_backtest(config_manager, data_manager, report_generator)
        
        elif choice == choices[3]:  # å‚æ•°ä¼˜åŒ–
            parameter_optimization(config_manager, data_manager)
        
        elif choice == choices[4]:  # å¤šé…ç½®å¯¹æ¯”æµ‹è¯•
            print("âš ï¸  å¤šé…ç½®å¯¹æ¯”åŠŸèƒ½å¼€å‘ä¸­...")
        
        elif choice == choices[5]:  # å¤šç­–ç•¥å¯¹æ¯”
            print("âš ï¸  å¤šç­–ç•¥å¯¹æ¯”åŠŸèƒ½å¼€å‘ä¸­...")
        
        elif choice == choices[6]:  # æ•°æ®ä¸‹è½½å™¨
            print("\nğŸš€ å¯åŠ¨æ•°æ®ä¸‹è½½å™¨...")
            try:
                from data_downloader import CryptoDataDownloader
                downloader = CryptoDataDownloader()
                downloader.interactive_download()
            except ImportError:
                print("âŒ æ•°æ®ä¸‹è½½å™¨æ¨¡å—æœªæ‰¾åˆ°")
            except Exception as e:
                print(f"âŒ æ•°æ®ä¸‹è½½å™¨å¯åŠ¨å¤±è´¥: {e}")
        
        elif choice == choices[7]:  # æŸ¥çœ‹æœ¬åœ°æ•°æ®
            local_data = get_local_data_summary()
            if local_data:
                print(f"\nğŸ“ æœ¬åœ°æ•°æ®æ‘˜è¦ (å…±{len(local_data)}ä¸ªå¸ç§):")
                print("-" * 60)
                for symbol, intervals in local_data.items():
                    print(f"{symbol:<12}: {', '.join(intervals)}")
            else:
                print("\nâŒ æœªæ‰¾åˆ°æœ¬åœ°æ•°æ®ï¼Œè¯·å…ˆä½¿ç”¨æ•°æ®ä¸‹è½½å™¨ä¸‹è½½æ•°æ®")
        
        elif choice == choices[8]:  # é€€å‡º
            print("ğŸ‘‹ ç¨‹åºé€€å‡º")
            break

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\nğŸ‘‹ ç¨‹åºè¢«ç”¨æˆ·ä¸­æ–­")
    except Exception as e:
        print(f"\nâŒ ç¨‹åºå¼‚å¸¸: {e}")
        import traceback
        traceback.print_exc()